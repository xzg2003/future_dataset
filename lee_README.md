# Welcome

[TOC]

这里是李亦凡的分支。用于分享、存储李亦凡的代码。

## lee.md文档说明

该md文档用于说明我的分支中的各个内容，记录我在每个任务中的**结果**、**问题**与**反思**。

## LEEyf分支说明

文件的存储、以及代码相应的规范要求，参考小组的任务要求。

为了避免数据集的传入，同时尽量减少对公共仓库的更改，我在本地设置了两个工作区，一个用于传输github文件，另一个完全镜像，用于我个人的代码编写与数据计算。

### .vscode文件夹

内部是settings.json文件，主要是工作区环境设置。同时在工作区内添加了部分词语的字典，避免系统拼写查错。

### factor_cal文件夹

因子计算文件，内部包括几个因子的.py计算文件，并通过类的封装全部集成在**factor_cal.py**，供程序调用。

#### 普通因子

各种因子如下（按字母名称排序）：

|           因子名称           |                             说明                             | 是否完成计算 | 是否完成评估 |
| :--------------------------: | :----------------------------------------------------------: | :----------: | :----------: |
|         FCT_Ac_Tr_1          |                  技术指标AC除以MA(TR)去量纲                  |      是      |      是      |
|           FCT_Ar_1           |          人气意愿指标，high、open、low差值累加对比           |              |              |
|          FCT_Bias_1          |                      乖离率除以Tr去量纲                      |              |              |
|           FCT_Br_1           |       人气意愿指标high, ref(close, 1), low差值累加对比       |              |              |
|          FCT_Cmf_1           | 资金流量指标，若收盘价在上半部分，且成交量放大，表示做多积极 |              |              |
|          FCT_Pubu_1          | 普及率因子，由短期均线和长期均线两条均线组成，衡量短期均线在长期均线窗口内的分位数位置 |              |              |
|      FCT_Pubu_Atr_Dfive      | 衡量短期均线在长期均线窗口内的分位数位置，并用 ATR 归一化，适合捕捉价格分布于波动率的关系 |              |              |
|      FCT_Pubu_Vol_Dfive      | 衡量短期均线在长期均线窗口内的分位数位置，并用成交量归一化，适合捕捉价格分布与成交活跃度的关系 |              |              |
|        FCT_R_Div_RStd        | 收益率与波动率比值因子，衡量单位波动下的收益率（动量/风险调整） |              |              |
|     FCT_Return_Cumsum_1      |        累积收益率因子，衡量从起始到当前的累积对数收益        |              |              |
|          FCT_Rsi_1           |                         相对强弱指标                         |              |              |
|          FCT_Sdrm_1          |        标准动量差因子，衡量收盘价在指定窗口内的波动性        |              |              |
|      FCT_Sdrm_Atr_Dfive      |  标准差动量与 ATR 归一化因子，衡量价格波动性与波动率的关系   |              |              |
|            FCT_Si            |     SI（波动率指标）因子，衡量收盘价的绝对变化幅度的均值     |              |              |
|           FCT_Srmi           | SRMI（相对动量指数）因子，衡量收盘价在指定窗口内的相对强弱位置 |              |              |
|   FCT_Support_Close_Thr_1    | 收盘价接近支撑位的次数因子，衡量收盘价在窗口内低于一定分位数的次数 |              |              |
| FCT_Support_Close_Thr_Boll_1 | 收盘价接近布林带下轨的次数因子，衡量收盘价在窗口内低于下轨的次数 |              |              |
|          FCT_Tsi_1           |                   TSI（趋势强度指标）因子                    |              |              |
|      FCT_Tsi_Atr_Dfive       |     趋势强度与 ATR 归一化因子，衡量单位波动下的趋势强度      |              |              |
|        FCT_TSI_Ref_1         |    TSI（真实强度指标）参考因子，衡量价格趋势的强弱和方向     |              |              |
|      FCT_Tsi_Vol_Dfive       |    趋势强度与成交量归一化因子，衡量单位成交量下的趋势强度    |              |              |
|          FCT_Vmacd           |       成交量 MACD 因子，衡量成交量的趋势变化和动能拐点       |              |              |
|     FCT_Vol_Close_Corr_1     | 成交量与收盘价相关系数因子，衡量指定窗口内成交量与收盘价的相关性 |              |              |
|       FCT_Vol_Cumsum_1       |         成交量累计因子，衡量从起始到当前的累计成交量         |              |              |
|       FCT_Vol_DFive_1        | 成交量动量因子，衡量成交量在指定窗口内的变化幅度（如标准差或均值） |              |              |
|    FCT_Vol_Return_Corr_1     | 成交量与收益率相关系数因子，衡量指定窗口内成交量与收益率的相关性 |              |              |
|            FCT_Vr            |    量比因子，衡量当前成交量与过去一段时间平均成交量的比值    |              |              |
|              Tr              | 波动幅度，当前k线的高低点与上根k线收盘价三者两两做差取绝对值最大的作为Tr波幅 |      是      |      是      |

#### 动量因子

动量因子反映了资产价格在一定时期内的延续性趋势。其基本原理是基于市场的非有效性，即资产价格不会立即对新信息做出充分反应，而是存在一定的滞后性。因此，在一段时间内，价格上涨（或下跌）的资产往往会继续保持上涨（或下跌）的趋势，这种趋势的强度和持续性就是动量因子所试图捕捉的。

|        动量因子名称        |                            说明                            | 是否完成计算 | 是否完成评估 |
| :------------------------: | :--------------------------------------------------------: | :----------: | :----------: |
|     时间序列动量TSMOM      |         用于衡量资产在过去一段时间内的累积收益情况         |              |              |
|      横截面动量XSMOM       | 通过比较同一时间点上不同资产的历史收益率，来预测其未来表现 |              |              |
|    加速因子Acceleration    |           用于衡量期货价格趋势强度和持续性的指标           |              |              |
| 日内动量 Intraday Momentem |              用于衡量一个交易日内价格变动趋势              |              |              |
|      相对强弱指标 RSI      |  用于衡量资产价格的相对强弱强度，来判断市场买卖力量的强弱  |              |              |

|   因子名称   |                   说明                    | 是否完成计算 | 是否完成评估 |
| :----------: | :---------------------------------------: | :----------: | :----------: |
| 简单截面动量 |            过去 K 天累积收益率            |              |              |
|   稳健动量   | 过去 K 天界面收益率排序后的标准化得分均值 |              |              |
|   趋势系数   |     简单动量基础上充分考虑路程的不同      |              |              |
|   日内动量   |           过去 K 天日内涨幅均值           |              |              |
|   隔夜动量   |           过去 K 天隔夜跳空均值           |              |              |
| RSI 动量因子 |   过去 K 天累积涨幅与累积绝对涨跌幅比值   |              |              |
|    乖离率    |              过去 K 天乖离率              |              |              |



### graphic

- graphic.py：图像绘制文件，利用计算得到的数据绘制图表。
- merge.py：因子合并文件，用于将不同期货类型中的同种因子合并在一个csv文件下。

### data(仅本地)

保存计算相关的数据。

- 5m：存储5分钟线的数据
- merge：存储不同期货品种的相同因子的合并数据集。
- mindiff：存储每个期货品种的最小变动单位。

### factor_judge

因子结果评估程序。具体方法已集成，结果会被存储在一个HTML文件中

### result（仅本地）

用于存储因子计算评估的结果

## 更新日志

### 2025-04-10：期货数据集的搭建与因子计算

#### 2025-04-14

- 尝试通过ricequant下载数据集，但由于相关问题，我本地的数据集构建并没有成功。
- 后面处理所用的数据集都是直接利用子栩学长提供的数据包进行操作的。

#### 2025-04-15

- **基础学习内容**：学习了python中的类、类的封装等概念，并完善了字典等数据类型的理解。
- **进阶学习内容**：学习了pandas中对于数据处理的相关函数，包括：对csv文件的操作，滑动平均计算等内容。
- **任务处理成果**：按照量化小组的任务文档，成功实现了六个因子的计算，并成功在main.py文件下跑通了整个程序。所有的期货类型都实现了处理，程序处理总时间为20分钟左右，总数据文件大小为4Gb。
- **本周任务小结**:对数据处理有了初步地了解，但是由于学习跳跃程度较大，仍有很多内容无法完全掌握，后期需要继续补足。
- **存在的问题**：在所给的数据包中，没有找到mindiff(期货品种的最小变动单位)这个变量，因此，相关的函数直接输出结果，而没有进行相应的判断。正确的函数参考注释部分。
- 学习内容来源主要参考B站上的python学习视频，同时利用了copilot和豆包这两个ai进行程序设计上的辅助。

#### 2025-04-16

- **修改内容**：调整了Tr因子的计算方法，删除了内部冗余的计算步骤，简化算法、
- 补充了相关的注释，使程序的可读性更强。
- 同时完成因子数据分布图的绘制

#### 2025-04-18 	**Task_1_1.0.1**

- **增加内容1**：增加了graphic文件夹用于绘制因子相关图像。但是目前只做了一个函数，还没有像factor_cal文件那样利用类对这些函数进行封装。
- **增加内容2**：增加了image文件夹，用于存储相关图像。

#### 2025-04-19 	**Task_1_1.0.2**

- **增加内容1**：在graphic文件夹下增加了merge.py文件，用于将在不同期货类型中的同种因子合并在一个csv文件下面。
- **增加内容2**：为了存储这个合并的csv文件，在data文件夹下，新增了一个./merge/5m/路径，用于存储合并后的csv文件，得到的csv文件命名为{factor}@{length}.csv。
- 最后利用graphic绘制图像
- **后续工作**：目前的merge和graphic文件都没有利用循环对所有因子、所有长度进行计算，如有需要，下一步工作将把这个函数封装为一个类，并将所有因子的图像绘制出来。

#### 2025-04-23 	**Task_1_1.0.3**

周常会议之后，根据子栩学长建议做出了优化。

- **因子计算器的优化**：在先前的计算器中，计算出来的因子名称为"{factor}"而不包含任何滑动长度的信息。这次更新将得到的结果改为正确的"{factor}@{length}"的形式。
- **传参的优化**：在先前的factor_calculator程序将带有length和不带length的因子计算分开处理，导致代码十分冗长。这次更新，优化了字典的传参，利用param传入length，以实现factor.formula(param)传参的统一，两种情况的重复代码也归并为同一种，仅保留因文件命名不同导致不同的代码部分。
- **后续工作**：现有的代码仍然没有考虑mindiff的问题，这次会议之后下载了mindiff的数据包，但是来不及对相关代码进行修改。后续将针对这一部分进行处理。

#### 2025-05-01	**Task_1_1.0.4**

根据之前存在的问题进行了相应的改动

- **加入mindiff参数**：根据之前会议的讨论结果，在这次的更新中，更新了关于mindiff（最小变动单位）的读入、比较与使用。进而完善了因子计算器，得到的结果也更加完整。具体的调用流程为：在 main 中读取 mindiff.csv 文件、设置字典、因子计算器计算。
- **优化计算器**：在先前的计算器中，每次都要重新计算一次滑动平均，大大增加了计算量。在此次更新中，通过修改计算逻辑，减少了相关的计算量。同时，修改了存储的时间格式，改为存储datetime

```python
# TR 的滚动均值并处理 NaN
rolling_mean_tr = df['Tr'].rolling(window=length).mean().fillna(0)

# 计算收盘价的滚动均值
rolling_mean_close = df['close'].rolling(window=length).mean().fillna(0)

# 打印调试信息
print(f"rolling_mean_tr: {rolling_mean_tr}")
print(f"rolling_mean_close: {rolling_mean_close}")

# 使用 numpy.where 进行分类处理
df[f'FCT_Bias_1@{length}'] = numpy.where(
 	rolling_mean_tr < mindiff,
	0,
	(df['close'] - rolling_mean_close) / rolling_mean_tr
 )
```

- 优化了 main.py 中的循环逻辑，简化了循环代码段，并利用判断语句，为循环提供出口，减少程序的计算量
- 增加各处的报错信息，便于查错

#### 2025-05-10	**Task_2_1.0.5**

- 修改 lee_README.md 文档，增加因子说明部分
- **算法优化**：先计算 Tr 因子，后续的因子里，当需要调用 Tr 因子的时候，可以直接读取 Tr.csv 文件来计算。可以简化运算。

### 2025-05-07：期货因子计算进阶

#### 2025-05-11	**Task_2_1.0.6**

- 增加因子计算器 TSMOM
- 增加因子计算器 XSMOM。存在以下问题没有解决：
  1. 根据网上查到的资料，横截面动量因子的命名是 CSMOM，是否需要替换？这里直接用学长给的图示进行计算。
  2. 网上查到的资料没有详细解释这个因子应该怎样进行计算。这个因子似乎需要做多做空后进行回测。这里没有进行回测计算的条件，因此没有做相关的计算。
  3. 关于窗口动量因子，需要一种期货类型的不同期货进行计算。我们所用的数据是主力合约，因此这里的计算严格讲是不严谨的。
- 增加因子计算器 Acceleration
- 增加因子计算器 IDMOM。原文给的名称是"Intraday Momentem"，这里为了与 TSMOM 和 XSMOM统一，编写程序时简写成了IDMOM，后入如果有规范，可以进行相应修改
- 增加因子计算器 RSI

目前只是完成了因子计算器的算法部分，还没有进行具体的调试。后续会逐步进行调试。新编写的因子计算器也没有放进 factor_cal 总计算器中，在后续调试的时候逐个放入。

#### 2025-05-13	**Task_2_1.0.7**

- 增加因子计算器 RobustMOM，稳健动量。这里缺乏命名格式，暂时命名为 RobustMOM。
- 增加因子计算器 TrendStrength，趋势系数。这里缺乏命名格式，暂时命名为 TrendStrength
- 增加因子计算器 IntradayMOM，日内动量。这里缺乏命名格式，暂时命名为 IntradayMOM
- 增加因子计算器 Overnight，隔夜动量因子。这里缺乏命名格式，暂时命名为 Overnight
- 增加因子计算器 Bias，乖离率因子。这里缺乏命名格式，暂时命名为 Bias

#### 2025-05-16	**Task_2_1.0.8**

- **因子计算器**

  - 增加因子计算器 FCT_Pubu_1，普及率因子。由于没有短期均线和长期均线的定义，保存文件的命名格式也没有标准。

  - 增加因子计算器 FCT_Pubu_Atr_Dfive，利用 ATR 归一化的普及率因子。由于没有短期均线、长期均线和ATR窗口的定义，保存文件的命名格式也没有标准。

  - 增加因子计算器 FCT_Pubu_Vol_Dfive，利用 Vol 归一化的普及率因子。由于没有短期均线、长期均线和Vol窗口的定义，保存文件的命名格式也没有标准。

  - 增加因子计算器 FCT_R_Div_RStd，收益率与波动率比值因子。这里应该可以直接利用  FCT_Return_Cumsum_1 的计算结果进行计算。

  - 增加因子计算器 FCT_Return_Cumsum_1，累积收益率因子。

  - 增加因子计算器 FCT_Rsi_1，相对强弱指标。在之前的更新中已经更新了 RSI 的因子计算器，因此这里没有具体编写 FCT_Rsi_1 因子计算器。

  - 增加因子计算器 FCT_Sdrm_Atr_Dfive，标准动量差与 ATR 归一化因子。

- **问题：**在今天更新的一系列因子计算器中可以看出，很多计算器需要调用 ATR 计算的结果，部分也需要先前 Tr 的计算结果。在后续的调试中，可以将这些内容归并在一起计算。
- **增加的内容：**
  - 在 lee_README.md （即本文）中增加了一个待办模块。程序编写、会议中提到的各种问题都被记录在这个小节中。
  - 补充部分因子说明
  
#### 2025-05-17

-   **因子计算器：**
  - 增加因子计算器 FCT_Sdrm_1，标准动量差因子。
  - 增加因子计算器 FCT_Si，SI（波动率指标）因子。
  - 增加因子计算器 FCT_Srmi，SRMI（相对动量指数）因子。
  - 增加因子计算器 FCT_Support_Close_Thr_1，收盘价接近支撑位的次数因子。目前缺乏 thr 这一比例，暂定为0.3
  - 增加因子计算器 FCT_Support_Close_Thr_Boll_1，收盘价接近布林带下轨的次数因子。目前缺乏 n_std 这一布林带标准差倍数，暂定为2
  - 增加因子计算器 FCT_Tsi_1，TSI（趋势强度指标）因子。缺少 long 和 short
  - 增加因子计算器 FCT_Vmacd，成交量 MACD 因子。缺少 fast，slow，signal 长度。

#### 2025-05-19	**Task_2_1.0.9**

- **因子计算器**
  - 增加因子计算器 FCT_Tsi_Atr_Dfive，趋势强度与ATR归一化因子。目前缺乏 short 和 long 的定义，无法完全完成计算。同时，计算器中可以调用 ATR 的计算结果进行计算，后续可以进行优化。
  - 增加因子计算器 FCT_TSI_Ref_1，TSI（真实强度指标）参考因子。目前缺乏 short 和 long 的定义，无法完全完成计算。同时，计算器中可以调用 EMA、TSI 的计算结果。
  - 增加因子计算器 FCT_Tsi_Vol_Dfive，趋势强度与成交量归一化因子。目前缺乏 short 和 long 的定义，无法完全完成计算。同时，计算器中可以调用 EMA、TSI 的计算结果。
  - 增加因子计算器 FCT_Vol_Close_Corr_1，成交量与收盘价相关系数因子。
  - 增加因子计算器 FCT_Vol_Cumsum_1，成交量累计因子。
  - 增加因子计算器 FCT_Vol_DFive_1，成交量动量因子。
  - 增加因子计算器 FCT_Vol_Return_Corr_1，成交量与收益率相关系数因子。
  - 增加因子计算器 FCT_Vr，量比因子。

### 2025-05-07：因子计算评估

#### 2025-05-24

- **因子计算评价程序：**
  - 将所给的因子计算评价程序合并到本分支中，成功带入并计算、评估部分因子的计算结果。为防止新的 main 程序与原程序形成冲突，这里将调用因子计算评价程序的主函数命名为 main_judge
  - 但是，学长原给的程序中存在部分问题，包括文件路径、时间类型等，在此为适应本地数据集，进行了相应的修改。
  - 此外，针对factor_name的读取问题进行了优化。在 factor_name.csv 中只留下因子名称，在主程序中利用循环，给每个因子名称加上后面的 @{length}，这样便于调用。
  - 在 main_judge 中还增加了一个判断语句，用于跳过已经评估过的因子。
- **代码调试：**
  - 修复 Acceleration 中存在的问题，保证因子计算器能正常进行运算。该因子计算器直接调用 TSMOM 的计算结果进行计算。同时对该因子进行计算评估
  - 修复 Bias 中存在的问题，保证因子计算器能正常进行运算。同时对该因子进行计算评估。
- 优化 factor_cal.py 的计算逻辑，保证计算过的因子不会再次被计算。
- 完善 delete程序，保证其正常运行

#### 2025-05-25

- **代码调试：**

  - 修复 XSMOM 中存在的问题，保证因子计算器能正常进行计算。同时对该因子进行计算评估。
  - 修复 RSI 中存在的问题，保证因子计算器能正常进行计算。同时对该因子进行评估。
  - 修复 IntradayMOM 中存在的问题，保证因子计算器能正常进行计算。
  - 修复 OvernightMOM 中存在的问题，保证因子计算器能正常进行计算。
  - 修复 RobustMOM 中存在的问题，保证因子计算器能正常进行计算，同时对该因子进行评估。
  - 修复 TrendStrengh 中存在的问题，保证因子计算器能正常进行计算，同时对该因子进行评估。
  - 修复 FCT_Pubu_1 中存在的问题，保证因子计算器能正常进行计算。

- **factor_cal优化：**

  - 由于不同各因子的名命名规则不同，因此，在 factor_cal 中进行了优化，通过列表的方式，对不同类型的因子进行分别处理。

    ```python
    # 设置保存路径，根据命名规则分开讨论
    if factor_name in self.no_length:
                                save_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), f'../data/{self.k_line_type}/{instrument}/{factor_name}.csv')
    elif factor_name in self.short_long:
                                save_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), f'../data/{self.k_line_type}/{instrument}/{factor_name}@{short}_{long}.csv')
    else:
                                save_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), f'../data/{self.k_line_type}/{instrument}/{factor_name}@{length}.csv')
    ```

#### 2025-05-26	**Task_3_1.1.1**

- 文件上传至 github 仓库，并更新版本号。
- **代码调试：**
  - 修复 FCT_Pubu_Atr_Dfive 中存在的问题，保证因子计算器能正常进行计算。同时，对该部分代码进行了优化，通过直接调用已经计算过的 Tr 和 FCT_Pubu_1 因子进行计算，大大简化计算量。
  - 修复 FCT_Pubu_Vol_Dfive 中存在的问题，保证因子计算器能正常进行计算。同时，对该部分代码进行了优化，通过直接调用已经计算过的 FCT_Pubu_1 因子进行计算，简化计算量。
  - 修复 FCT_R_Div_RStd 中存在的问题，保证因子计算器能正常进行计算。

#### 2025-05-27	**Task_3_1.1.2**

- **代码调试：**

  - 修复 FCT_Return_Cumsum_1 中存在的问题，保证因子计算器能正常进行计算。
  - 修复 FCT_Sdrm_Atr_Dfive 中存在的问题，保证因子计算器能正常进行计算。
  - 修复 FCT_Si 中存在的问题，保证因子计算器能正常进行计算。
  - 修复 FCT_Srmi 中存在的问题，保证因子计算器能正常进行计算。
  - 修复 FCT_Support_Close_Thr_1 中存在的问题，保证因子计算器能正常进行计算。
  - 修复 FCT_Support_Close_Thr_Boll_1 中存在的问题，保证因子计算器能正常进行计算。
  - 修复 FCT_Tsi_1 中存在的问题，保证因子计算器能正常进行计算。
  - 修复 FCT_Tsi_Atr_Dfive 中存在的问题，保证因子计算器能正常进行计算。
  - 修复 FCT_TSI_Ref_1 中存在的问题，保证因子计算器能正常进行计算。
  - 修复 FCT_Vmacd 中存在的问题，保证因子计算器能正常进行计算。
  - 修复 FCT_Vol_Cumsum_1 中存在的问题，保证因子计算器能正常进行计算。
  - 修复 FCT_Vol_DFive_1 中存在的问题，保证因子计算器能正常进行计算。
  - 修复 FCT_Vol_Return_Corr_1 中存在的问题，保证因子计算器能正常进行计算。
  - 修复 FCT_Vr 中存在的问题，保证因子计算器能正常进行计算。

  至此，目前所有的因子计算器都进行完调试。后续将利用评估程序对各个因子的计算结果进行评估。同时，还会针对代码中的相关问题进行风格上、逻辑上的优化。

#### 2025-05-31	**Task_3_1.1.2.optimal**

- **程序结构优化：config.py 文件的使用**
  - 对程序结构进行了优化，在程序的根目录下对 config.py 进行了修改。程序中的其他程序可以统一调用 config.py 中的元素并进行后续计算。经过这样的优化，对各个计算子程序的维护将更加方便，也不会出现不同子程序中的设置不同而导致无法准确对接的问题。
  - **factor_cal.py 的修改：**直接里利用 config.py 的默认参数，factor_cal.py 中通过程序自动化导入，对每个因子计算器进行导入，并构建出因子名称的字典。还对传参字典 param 进行了优化，利用 config.py 中的数据导入 param 中，使param 的参数可以灵活使用。 
  - **main_judge.py 的修改：**直接利用 config.py 的默认参数。利用循环，对每个因子的每个窗口长度进行计算。
  - **delete.py 的修改：**直接利用 config.py 的默认参数，这里添加了输入模块，允许用户手动输入因子名称，手动删除，同时输入0退出程序。

#### 2025-06-01	**Task_3_1.1.3**

- **将 LEEyf_程序结构优化 变基到 LEEyf 中**

#### 2025-06-02	**Task_3_1.1.3.multiprocessing**

- 新的分支 **LEEyf_multiprocessing**：尝试利用并行计算，充分使用 CPU 核心的资源。
  - 在 main 中的使用：在 main 中，直接使用并行运算。我的电脑的 CPU 是16核的，所以理论上，这样操作后的计算速率能提高16倍率（但实际上也会受到内存容量的影响）。总体上，原本预计需要27个小时的计算，被缩短到了3小时左右完成。
  - 在 main_judge 中的使用：在 main_judge 中，在尝试 CPU 满载计算的时候出现内存溢出的问题，原因是：在进行统计分析的时候，需要将每个因子计算结果进行拼接，大量的数据堆放在缓存区，导致内存溢出。经过调整，我的电脑只能支持2-3核的计算。每个因子的计算结果全都评估完成。
- 修复 statistic.py 中的问题：
  - 原有的 statistic 中的时间参数被写为 date，这个问题导致无法找到因子计算结果中的 datetime，进而导致 mutal_IC 计算出错。
  - 原有的 statistic 中的因子名称是对 factor_name.csv 中的名称进行读取，但是在结构优化后，因子名称需要调用 config.py 中的内容进行计算。
- 修复 mutal_IC 中的问题：
  - 原有的 statistic 中的因子名称是对 factor_name.csv 中的名称进行读取，但是在结构优化后，因子名称需要调用 config.py 中的内容进行计算。
  - 计算因子时出现 IDE 崩溃的问题，原因拼接后的数据过大，导致内存溢出。经过修改，对内存溢出的问题进行了修改。但是计算后得到的只是一个空文件。后续仍然需要对 mutal_IC 进行修改



#### 2025-06-06

- 将学长写好的内容合并至本分支中，给 statistic.py 和 factor_judge.py 中添加了对因子极值的裁剪。
- 尝试将根目录下的 mian.py 合并到 factor_cal.py 里面，但是出现包的导入问题，无法直接在子目录下运行。在根目录下通过终端运行。这里暂且不删除 main.py
- **修改因子名称导入逻辑：LEEyf_factornames-in-csv**
  - 在先前的因子导入逻辑中，是利用了一个较为复杂的循环对每个因子名称进行拼接。虽然高度自动化，但是维护起来仍然不方便，现在改为半自动的导入，通过 factor_name.csv 来导入每个因子的名称。为此，程序还需要进行下面的各种优化，以达到最优的效果。
  - 利用 factor_name.csv 导入的时候仍然出现问题，原因是：在利用 factor_name.csv 文件读入因子名称的时候，会自然带上后缀名称，但是相应的因子的包是不带这些后缀的，在这里产生了冲突。为了解决这一问题，在提取因子名称的时候，还对因子名称的后缀进行了分割的处理，以保证包的导入路径与结果的存储路径不会出现冲突。分割的原理为：由于因子名称的命名中，利用 @ 将基础名称与后续的参数进行了分割，在因子的包的导入的时候，直接利用基础名称对包进行导入，在保存因子路径的时候，则再把两个部分合并在一起。
  - 由于放弃了利用包的形式导入 factor_names，无法使用全局的数据，因此 factor_calculator 这个类需要额外增加一个 factor_name 的参数，用来导入因子名称的 dataframe。
  - 由于手动输入的因子名称中已经包含了各个参数，尤其是 length，因此，程序中对 length 的循环逻辑也就没必要了，只需要将 length 视为一个普通的参数即可

#### 2025-06-08

- **版本回退**：由于版本管理上的问题，LEEyf 这个分支出现混乱，现在从 Task_3_1.1.3.multiprocessing 直接回退一个版本。保证 LEEyf 这个个人工作分支能正常运作。但与此同时，先前计算好的结果也被**删库**，正好这次的工作需要把逐一观察每个因子的评估效果，所以……从头算吧（哭）
- 由于先前对 factor_name.csv 导入的工作进行不顺，编写的程序出现各种各样的问题，这里只能重新对程序结构进行编写。并开出新的分支。这里新建了一个 LEEyf_judge 分支，用于放入评估程序的更新内容。
- 在 lee_README 文件中，在因子的介绍表格中增加了 “是否完成计算”和“是否完成评估”两列，以标记相关工作内容，避免重复与遗漏。
- **LEEyf_judge:**
  - 在处理与评估因子计算结果的时候，由于先前对因子结果的存储为 ‘datetime’ 而不是 ‘date’，这导致因子评估程序不能识别相应的结果，导致计算错误，因此，这里需要将每个因子计算器的结果返回均改为返回 ‘date’，以避免冲突。每个一因子都已修改。
    - 修改 Tr 因子计算器。
    - 修改 FCT_Ac_Tr_1 因子计算器。
- 由于 5m 数据集过大，暂时使用 1d 数据集，来分析、评估因子计算结果。

#### 2025-06-10

- 完成因子计算器的计算与验证：这里先保证因子计算器能正常计算，所以暂时只对10这个时间窗口进行了计算。
- 关于因子评估时，对因子名称的导入，这里有一个灵感，由于因子评估的时候，导入因子名称需要一个 .csv 文件，这个文件中写入因子名称，但是手动进行计算较为麻烦，是否可以在因子计算器进行计算的时候，通过自动化导入来对文件进行写入？
- 对部分因子计算器进行细节上的处理，让因子计算器能针对不同k线类型灵活进行计算，尤其是那些需要引用先前计算结果的计算器，保证其能进行计算的同时，增强鲁棒性。

#### 2025-06-12

- 新建分支 LEEyf_functions ，用于给程序增加新的功能。这个分支管理方法参考了企业里程序开发的逻辑，把 LEEyf 视为主分支，LEEyf_functions 用于给程序增加新的功能等，后续还会增加 LEEyf_test 用于给程序进行相应的测试或调试。这样的分支管理就不需要给分支命名为具体的功能（如先前的 LEEyf_multiprocessing），所有新增的功能都可以在这个分支里面进行处理。
- 修改因子命名逻辑：先前的因子命名将因子需要的所有参数都放入了名称中，这使得一些因子名称的计算结果相当臃肿。而且这不便于利用 factor_name.csv 来对因子进行导入。因此，所有因子的计算结果的命名都统一为 {factor}@{length} 这样方便后续程序中的处理。

## 待办

- 2025-05-16
  - [x] 时间窗口
    - [x] 更新的计算器中缺少长期均线、短期均线和ATR窗口长度的定义，目前使用默认窗口长度进行计算，后续需要进行补全
    - [x] 因子计算器的命名需要格式化，目前的命名暂定为"factor@{short}_{long}"
  - [x] 部分因子的计算可以调用其他因子已计算得到的结果进行计算，简化代码
- 2025-05-17
  - [x] FCT_Support_Close_Thr_1 因子计算器中，缺少 thr 比例.
  - [x] FCT_Support_Close_Thr_Boll_1 因子计算器中，缺少 n_std.
  - [x] FCT_Tsi_1 因子计算器中，缺少 long 和 short
- 2025-05-19
  - [x] FCT_Tsi_Atr_Dfive 因子计算器中，缺少 long 和 short。
  - [x] FCT_Tsi_Atr_Dfive 因子计算器中，可以调用 ATR 的计算结果进行优化
  - [x] FCT_TSI_Ref_1 因子计算器中，缺少 long 和 short
  - [x] FCT_TSI_Ref_1 因子计算器中，可以调用 TSI 的计算结果
  - [x] FCT_Tsi_Vol_Dfive 因子计算器中，缺少 long 和 short
  - [x] FCT_Tsi_Vol_Dfive 因子计算器中，可以调用 TSI 的计算结果
  - [x] FCT_Vmacd 因子计算器中，缺少 fast、slow、signal 几个长度。
- 2025-05-25
  - [x] 在 main 的计算过程中出现新的问题：每次调用 main 进行计算时都会陷入循环调用 “FCT_Ar_Tr_1" 这个因子库，但后续的计算依然可以进行。相关问题尚未找到。
- 2025-05-27
  - [x] factor_cal
    - [x] 在 factor_cal 总因子计算器中，为满足不同因子的命名名称，在 param 中增加了不同的约定，并对不同命名方式的因子进行了分类，在循环中进行分类
    - [x] 在 factor_cal 总因子计算器中，双层循环存在问题，该问题导致没有 length 的因子会在 length 循环中重复计算6次。后续需要修改循环逻辑对这个问题进行优化。
    - [x] 在 factor_cal 总因子计算器中，前面的导入部分过长，可以进行相应的优化。

  - [ ] 在 FCT_Vol_Close_Corr_1 因子计算器中，存在数据无法读入的问题，强行将数据变成二维的 dataframe 后，计算得到的结果恐怕有误。
- 2025-05-31
  - [ ] 因子评估程序：
    - [ ] mutal_IC 始终无法计算出，由于没有相关的计算规则，无法对这个部分进行修正

  - [x] k线类型：目前只计算了 5m 的类型，因此 config.py 中对k线类型的处理是直接写死为 5m，如果后续需要计算其他类型的k线，需要将这个参数改为一个列表，对应的，其他程序中的 k_line_type 也要进行相应的修正。目前为避免麻烦，没有在这类进行过多复杂的修改。
- 2025-06-08
  - [ ] 在并行运算时，会出现同一个因子被多个 cpu 重复计算，这本质其实还是循环逻辑复杂，混乱的表现，后续需要针对循环逻辑进行优化，避免一个因子被反复计算。

- 2025-06-10

  - [ ] 存在问题的因子计算器：

    - [ ] FCT_Pubu_1：相关问题如下

      ```python
              def pubu_percentile(x):
                  window = x[-long:]
                  if len(window) < long or numpy.all(numpy.isnan(window)):
                      return numpy.nan
                  return numpy.sum(window <= window[-1]) / long
      
              df[f'FCT_Pubu_1@{short}_{long}'] = df['ma_short'].rolling(window=long, min_periods=long).apply(pubu_percentile, raw=True)
      ```

      这一段处理是否合理，而且在本地跑的时候，基本上都会出现 nan 的数据
